import * as preact from 'preact';
import { JSX, FunctionalComponent, VNode, ComponentChildren, FunctionComponent } from 'preact';
import { Signal } from '@preact/signals';
import { AttachmentTestStepResult, Statistic, TestStatus, TestStatusTransition, PieChartValues, TreeMapNode, TestResult } from '@allurereport/core-api';
import { RecursiveTree, Status } from 'global';
import * as preact_compat from 'preact/compat';
import { HTMLAttributes, CSSProperties } from 'preact/compat';
import { Options } from 'sortablejs';
import { LangLocale, TreeMapTooltipAccessor } from '@allurereport/web-commons';
import { ChartMode, BarGroup } from '@allurereport/charts-api';
import { Serie as Serie$1 } from '@/components/Charts/TrendChart';
import { AxisProps } from '@nivo/axes';
import { Serie as Serie$2, Datum as Datum$1, LineSvgProps, Point } from '@nivo/line';
import { ScaleSymlogSpec, ScaleSpec } from '@nivo/scales';
import { Margin } from '@nivo/core';
import { LegendProps, AnchoredContinuousColorsLegendProps } from '@nivo/legends';
import { BarDatum, ResponsiveBarSvgProps, BarLegendProps } from '@nivo/bar';
import { DefaultTreeMapDatum, TreeMapSvgProps } from '@nivo/treemap';
import { HeatMapDatum, DefaultHeatMapDatum, HeatMapSvgProps } from '@nivo/heatmap';

declare const allureIcons: {
    amazon: string;
    arrowsChevronDown: string;
    azure: string;
    bitbucket: string;
    circleci: string;
    draggable: string;
    drone: string;
    environment: string;
    github: string;
    gitlab: string;
    jenkins: string;
    lineAlertsAlertCircle: string;
    lineAlertsFixed: string;
    lineAlertsMalfunctioned: string;
    lineAlertsNew: string;
    lineAlertsNotificationBox: string;
    lineAlertsRegressed: string;
    lineArrowsChevronDown: string;
    lineArrowsChevronDownDouble: string;
    lineArrowsChevronRight: string;
    lineArrowsChevronUp: string;
    lineArrowsChevronUpDouble: string;
    lineArrowsCornerDownRight: string;
    lineArrowsExpand3: string;
    lineArrowsRefreshCcw1: string;
    lineArrowsSortLineAsc: string;
    lineArrowsSortLineDesc: string;
    lineArrowsSwitchVertical1: string;
    lineChartsBarChartSquare: string;
    lineChartsTimeline: string;
    lineDevBug2: string;
    lineDevCodeSquare: string;
    lineDevDataflow3: string;
    lineFilesClipboardCheck: string;
    lineFilesFile2: string;
    lineFilesFileAttachment2: string;
    lineFilesFolder: string;
    lineGeneralCheck: string;
    lineGeneralCheckCircle: string;
    lineGeneralChecklist3: string;
    lineGeneralCopy3: string;
    lineGeneralDownloadCloud: string;
    lineGeneralEqual: string;
    lineGeneralEye: string;
    lineGeneralHelpCircle: string;
    lineGeneralHomeLine: string;
    lineGeneralInfoCircle: string;
    lineGeneralLink1: string;
    lineGeneralLinkExternal: string;
    lineGeneralMinusCircle: string;
    lineGeneralSearchMd: string;
    lineGeneralSettings1: string;
    lineGeneralXCircle: string;
    lineGeneralXClose: string;
    lineGeneralZap: string;
    lineHelpersFlag: string;
    lineHelpersPlayCircle: string;
    lineIconBomb2: string;
    lineImagesImage: string;
    lineLayoutsColumn2: string;
    lineLayoutsLayoutTop: string;
    lineLayoutsMaximize2: string;
    lineLayoutsMinimize2: string;
    lineSecurityKey: string;
    lineShapesDotCircle: string;
    lineShapesMoon: string;
    lineShapesSun: string;
    lineShapesThemeAuto: string;
    lineTimeClockStopwatch: string;
    playwrightLogo: string;
    reportLogo: string;
    solidAlertCircle: string;
    solidCheckCircle: string;
    solidHelpCircle: string;
    solidMinusCircle: string;
    solidPlusCircle: string;
    solidXCircle: string;
    spinner: string;
    testNew: string;
    view: string;
    viewOff: string;
};
type SvgIconProps = Omit<JSX.HTMLAttributes<SVGElement>, "className" | "id" | "size" | "inline"> & {
    "size"?: "xs" | "s" | "m";
    "className"?: string;
    "id": string;
    "inline"?: boolean;
    "data-testid"?: string;
};
declare const SvgIcon: ({ id, size, inline, className, "data-testid": dataTestId, ...restProps }: SvgIconProps) => JSX.Element;

type BaseBtnProps = {
    text?: string;
    isPending?: boolean;
    size?: "s" | "m" | "l";
    style?: "primary" | "outline" | "ghost" | "flat" | "raised";
    action?: "default" | "danger" | "positive";
    icon?: string;
    iconSize?: "xs" | "s" | "m";
    fullWidth?: boolean;
    isIconButton?: boolean;
    isDropdownButton?: boolean;
    onClick?: (e: MouseEvent) => void;
    type?: HTMLButtonElement["type"];
    isDisabled?: boolean;
    isActive?: boolean;
    focusable?: boolean;
    href?: string;
    target?: HTMLAnchorElement["target"];
    className?: string;
    dataTestId?: string;
};
type ButtonProps = Omit<BaseBtnProps, "text" | "isIconButton" | "isDropdownButton"> & Pick<Required<BaseBtnProps>, "text">;
declare const Button: (props: ButtonProps) => preact.JSX.Element;
type IconButtonProps = Omit<BaseBtnProps, "text" | "icon" | "autoFocus" | "fullWidth" | "isIconButton" | "isDropdownButton"> & Pick<Required<BaseBtnProps>, "icon">;
declare const IconButton: (props: IconButtonProps) => preact.JSX.Element;
type DropdownButtonProps = Omit<BaseBtnProps, "type" | "autoFocus" | "isDropdownButton" | "isIconButton" | "text" | "isActive"> & Pick<Required<BaseBtnProps>, "text"> & {
    isExpanded?: boolean;
};
declare const DropdownButton: (props: DropdownButtonProps) => preact.JSX.Element;

type SpinnerProps = {
    size?: "s" | "m";
};
declare const Spinner: ({ size }: SpinnerProps) => preact.JSX.Element;

type TextProps = ({
    type?: "paragraph";
    size?: "s" | "m" | "l";
} | {
    type: "ui";
    size: "s" | "m" | "l" | "xs";
}) & {
    className?: string;
    bold?: boolean;
    tag?: keyof JSX.IntrinsicElements;
} & Omit<JSX.HTMLAttributes, "type" | "size" | "className" | "bold" | "tag">;
declare const Text: FunctionalComponent<TextProps>;
type CodeProps = {
    type?: "paragraph" | "ui";
    size?: "s" | "m";
    className?: string;
    bold?: boolean;
    tag?: keyof JSX.IntrinsicElements;
};
declare const Code: FunctionalComponent<CodeProps>;
type HeadingProps = {
    size?: "s" | "m" | "l";
    className?: string;
    tag?: keyof JSX.IntrinsicElements;
} & Omit<JSX.HTMLAttributes, "size" | "className" | "tag">;
declare const Heading: FunctionalComponent<HeadingProps>;

interface TooltipWrapperProps {
    "tooltipText"?: string;
    "tooltipTextAfterClick"?: string;
    "tooltipComponent"?: FunctionalComponent | VNode;
    "children": VNode;
    "placement"?: "top" | "bottom" | "left" | "right";
    "triggerMode"?: "hover" | "click";
    "autoHideDelay"?: number;
    "isTriggerActive"?: boolean;
    "data-testid"?: string;
}
declare const TooltipWrapper: FunctionalComponent<TooltipWrapperProps>;

interface StoreSignalState<T> {
    error?: string;
    loading: boolean;
    data?: T;
}
type LoadableProps<T, K = T> = {
    source: Signal<StoreSignalState<T>>;
    transformData?: (data: T) => K;
    renderData: (data: K) => JSX.Element;
    renderLoader?: () => JSX.Element;
    renderError?: (error: string) => JSX.Element;
};
declare const Loadable: <T, K = T>(props: LoadableProps<T, K>) => JSX.Element | null;

declare const PageLoader: () => preact.JSX.Element;

type Props$7 = {
    placeholder?: string;
    invalid?: string;
    error?: string;
    value: string;
    onChange: (value: string) => void;
    changeDebounce?: number;
};
declare const SearchBox: (props: Props$7) => preact.JSX.Element;

declare const Menu: {
    (props: {
        children: ComponentChildren;
        isInitialOpened?: boolean;
        size?: "s" | "m" | "l" | "xl";
        placement?: "bottom-start" | "bottom-end";
        menuTrigger: (props: {
            onClick: () => void;
            isOpened: boolean;
            setIsOpened: (isOpened: boolean) => void;
        }) => VNode;
        menuTriggerWrapper?: "div" | "span";
    }): preact.JSX.Element;
    Section(props: {
        children: ComponentChildren;
    }): preact.JSX.Element;
    Item(props: ItemProps): preact.JSX.Element;
    ItemWithCheckmark(props: ItemProps & {
        isChecked: boolean;
    }): preact.JSX.Element;
};
type ItemProps = {
    children: ComponentChildren;
    onClick?: () => void;
    leadingIcon?: string;
    rightSlot?: ComponentChildren;
    closeMenuOnClick?: boolean;
    ariaLabel?: string;
    setIsOpened?: (isOpened: boolean) => void;
};

interface ArrowButtonProps {
    isOpened?: boolean;
    iconSize?: "m" | "xs" | "s";
    buttonSize?: "m" | "xs" | "s";
    className?: string;
    icon?: string;
    onClick?: VoidFunction;
    tag?: keyof JSX.IntrinsicElements;
}
declare const ArrowButton: FunctionalComponent<ArrowButtonProps>;

type ModalGalleryProps = {
    attachments: AttachmentTestStepResult[] | undefined;
};
interface ModalDataProps<T = any> {
    data?: T;
    component: VNode;
    preview?: boolean;
    isModalOpen?: boolean;
    closeModal?: () => void;
    attachments?: AttachmentTestStepResult[];
    title?: string;
}
interface ModalTranslations {
    tooltipPreview: string;
    tooltipDownload: string;
    openInNewTabButton: string;
}
interface ModalTranslationsProps {
    translations: ModalTranslations;
}
declare const Modal: ({ data, isModalOpen, preview, component, attachments, closeModal, translations, title, }: ModalDataProps & ModalTranslationsProps) => preact.JSX.Element | null;

interface TreeProps {
    statistic?: Statistic;
    reportStatistic?: Statistic;
    tree: RecursiveTree;
    name?: string;
    root?: boolean;
    statusFilter?: Status;
    collapsedTrees: Set<string>;
    toggleTree: (id: string) => void;
    navigateTo: (id: string) => void;
    routeId?: string;
}
declare const Tree: FunctionalComponent<TreeProps>;

interface TreeHeaderProps {
    statistic?: Statistic;
    reportStatistic?: Statistic;
    categoryTitle: string;
    isOpened: boolean;
    toggleTree: () => void;
    statusFilter?: Status;
}
declare const TreeHeader: FunctionComponent<TreeHeaderProps>;

interface TreeSectionProps {
    title: string;
    isOpened: boolean;
    toggleTree: () => void;
    icon?: string;
}
declare const TreeSection: FunctionComponent<TreeSectionProps>;

interface TreeItemProps {
    name: string;
    status: TestStatus;
    duration?: number;
    retriesCount?: number;
    flaky?: boolean;
    transition?: TestStatusTransition;
    transitionTooltip?: string;
    id: string;
    groupOrder: number;
    marked?: boolean;
    navigateTo: (id: string) => void;
}
declare const TreeItem: FunctionComponent<TreeItemProps>;

interface TestStatusIconProps {
    status?: TestStatus;
    className?: string;
    classNameIcon?: string;
}
declare const TreeItemIcon: FunctionalComponent<TestStatusIconProps>;

interface TreeStatusBarProps {
    statistic?: Statistic;
    reportStatistic?: Statistic;
    maxWidth?: number;
    minWidth?: number;
    offset?: number;
    statusFilter?: Status;
}
declare const TreeStatusBar: FunctionalComponent<TreeStatusBarProps>;

interface AttachmentTestStepResultProps {
    item: AttachmentTestStepResult;
    previewable?: boolean;
}
declare const Attachment: FunctionalComponent<AttachmentTestStepResultProps>;

declare const AttachmentCode: FunctionalComponent<{
    item: AttachmentTestStepResult;
    attachment: {
        text?: string;
    };
}>;

type HtmlAttachmentPreviewProps = {
    attachment: {
        text: string;
    };
};
declare const HtmlPreview: FunctionalComponent<HtmlAttachmentPreviewProps>;

declare const AttachmentImage: FunctionalComponent<{
    attachment: {
        img: string;
        originalFileName: string;
    };
}>;

declare const AttachmentVideo: FunctionalComponent<{
    attachment: {
        src: string;
        contentType?: string;
    };
}>;

declare const AttachmentEmpty: ({ children }: {
    children: ComponentChildren;
}) => preact.JSX.Element;

declare const CodeViewer: FunctionalComponent<{
    code?: string;
    children?: ComponentChildren;
    className?: string;
}>;

type Props$6 = {
    size?: "s" | "m" | "l";
    count: number;
    truncateCount?: boolean;
    status?: TestStatus;
};
declare const Counter: (props: Props$6) => preact.JSX.Element;

type Props$5 = {
    value: boolean;
    label: string;
    onChange: (value: boolean) => void;
    focusable?: boolean;
};
declare const Toggle: (props: Props$5) => preact.JSX.Element;

type Props$4 = {
    href?: string;
    children: ComponentChildren;
    onClick?: (e: MouseEvent) => void;
};
declare const Link: (props: Props$4) => preact.JSX.Element;

declare const Label: FunctionComponent;

type StatusLabelProps = {
    status: TestStatus;
    className?: string;
};
declare const StatusLabel: FunctionalComponent<StatusLabelProps>;

declare const ReportLogoFull: (props: {
    className?: string;
}) => preact.JSX.Element;

declare const ReportLogo: (props: {
    className?: string;
    logo?: string;
}) => preact.JSX.Element;

interface WidgetProps {
    title?: string;
    centerContent?: boolean;
    dropShadow?: boolean;
}
declare const Widget: FunctionalComponent<WidgetProps>;

type TagSkin = "successful" | "failed" | "warning" | "neutral" | "successful-light" | "failed-light" | "warning-light" | "neutral-light";
interface TagProps {
    "className"?: string;
    "skin"?: TagSkin;
    "data-testid"?: string;
}
declare const Tag: FunctionComponent<TagProps>;

type GridKind = "default" | "swap";
interface GridProps extends HTMLAttributes<HTMLDivElement> {
    options?: Options;
    kind?: GridKind;
    className?: string;
}
declare const Grid: FunctionComponent<GridProps>;

interface GridItemProps extends HTMLAttributes<HTMLDivElement> {
    className?: string;
    dndEnabled?: boolean;
}
declare const GridItem: FunctionComponent<GridItemProps>;

interface LanguagePickerProps {
    locale: LangLocale;
    setLocale: (locale: LangLocale) => void;
    availableLocales?: LangLocale[];
}
declare const LanguagePicker: ({ locale, setLocale, availableLocales }: LanguagePickerProps) => preact.JSX.Element;

type Theme = "light" | "dark" | "auto";
interface ThemeButtonProps {
    theme: Theme;
    getTheme: () => void;
    toggleTheme: () => void;
}
declare const ThemeButton: ({ theme, toggleTheme, getTheme }: ThemeButtonProps) => preact.JSX.Element;

type Props$3 = {
    icon: string;
    tooltip?: string;
    className?: string;
    style?: "primary" | "secondary";
};
declare const IconLabel: FunctionalComponent<Props$3>;

interface TrendChartWidgetPropsTranslations {
    "no-results": string;
}
interface TrendChartWidgetProps<TSlice = {
    metadata: {
        executionId: string;
    };
}> {
    title: string;
    mode: ChartMode;
    items: readonly Serie$1[];
    slices: readonly TSlice[];
    min: number;
    max: number;
    height?: CSSProperties["height"];
    width?: CSSProperties["width"];
    rootAriaLabel?: string;
    translations: TrendChartWidgetPropsTranslations;
    dropShadow?: boolean;
}
declare const TrendChartWidget: ({ title, mode, items, slices, min, max, height, width, rootAriaLabel, translations, }: TrendChartWidgetProps) => preact_compat.JSX.Element;

interface ComingSoonChartWidgetProps {
    title: string;
}
declare const ComingSoonChartWidget: FunctionalComponent<ComingSoonChartWidgetProps>;

type SuccessRatePieChartProps = PieChartValues & {
    className?: string;
};
declare const SuccessRatePieChart: ({ slices, percentage, className }: SuccessRatePieChartProps) => preact.JSX.Element;

type Datum = Omit<Datum$1, "x" | "y"> & {
    x: string | number | Date;
    y: number;
};
type Serie = Omit<Serie$2, "id" | "data"> & {
    id: string | number;
    data: readonly Datum[];
};
type BaseLineSvgProps = Omit<LineSvgProps, "useMesh" | "enableSlices">;
declare enum TrendChartKind {
    Mesh = "Mesh",
    SlicesX = "SlicesX",
    SlicesY = "SlicesY"
}
type TrendChartKindConfig = Pick<LineSvgProps, "useMesh" | "enableSlices">;
type SymlogScaleOptions = Pick<ScaleSymlogSpec, "constant" | "reverse">;
interface Slice {
    id: string;
    height: number;
    width: number;
    x: number;
    y: number;
    x0: number;
    y0: number;
    points: Point[];
}
type TrendChartSliceClickHandler = (slice: Slice, event: MouseEvent) => void;
type TrendChartSliceTouchHandler = (slice: Slice, event: TouchEvent) => void;
interface BaseTrendChartProps extends Omit<BaseLineSvgProps, "onClick" | "onTouchEnd" | "axisBottom"> {
    rootAriaLabel?: string;
    emptyLabel?: string;
    emptyAriaLabel?: string;
    width?: CSSProperties["width"];
    height?: CSSProperties["height"];
    axisBottom?: Omit<AxisProps, "tickValues">;
}
interface MeshTrendChartProps extends BaseTrendChartProps {
    kind: TrendChartKind.Mesh;
    onClick?: (point: Point, event: MouseEvent) => void;
    onTouchEnd?: (point: Point, event: TouchEvent) => void;
}
interface SlicesTrendChartProps extends BaseTrendChartProps {
    kind: TrendChartKind.SlicesX | TrendChartKind.SlicesY;
    onSliceClick?: TrendChartSliceClickHandler;
    onSliceTouchEnd?: TrendChartSliceTouchHandler;
}
type TrendChartProps = MeshTrendChartProps | SlicesTrendChartProps;

declare const TrendChart: FunctionalComponent<TrendChartProps>;

declare const defaultTrendChartLegendConfig: LegendProps;
declare const defaultTrendChartAxisBottomConfig: AxisProps;
declare const defaultTrendChartAxisLeftConfig: AxisProps;
declare const defaultTrendChartMarginConfig: Margin;
declare const defaultTrendChartXScaleConfig: ScaleSpec;
declare const defaultTrendChartYScaleConfig: ScaleSpec;
declare const defaultTrendChartConfig: Partial<LineSvgProps>;

declare const makeSymlogScale: (min: number, max: number, options?: SymlogScaleOptions) => ScaleSymlogSpec;
declare const makeSymlogScaleBySeries: (series: Serie[], options?: SymlogScaleOptions) => ScaleSymlogSpec;

interface BarChartProps<D extends BarDatum> extends ResponsiveBarSvgProps<D> {
    width?: CSSProperties["width"];
    height?: CSSProperties["height"];
    rootAriaLabel?: string;
    emptyLabel?: string;
    emptyAriaLabel?: string;
}

declare const BarChart: FunctionalComponent<BarChartProps<BarDatum>>;

declare const defaultBarChartMarginConfig: Margin;
declare const defaultBarChartAxisBottomConfig: AxisProps;
declare const defaultBarChartAxisLeftConfig: AxisProps;
declare const defaultBarChartLegendsConfig: BarLegendProps;
declare const defaultBarChartConfig: Partial<ResponsiveBarSvgProps<BarDatum>>;

type AxisConfig$1 = {
    legend?: string;
    enabled?: boolean;
    format?: string;
    tickValues?: number | number[];
    domain?: number[];
};
interface BarChartWidgetProps {
    title: string;
    mode: ChartMode;
    data: BarGroup<string, string>[];
    keys: readonly string[];
    indexBy: string;
    groupMode: "grouped" | "stacked";
    height?: CSSProperties["height"];
    width?: CSSProperties["width"];
    rootAriaLabel?: string;
    colors: Record<string, string>;
    translations: Record<string, string>;
    yAxisConfig?: AxisConfig$1;
    xAxisConfig?: AxisConfig$1;
    layout?: "horizontal" | "vertical";
}

declare const BarChartWidget: FunctionalComponent<BarChartWidgetProps>;

type ResponsiveTreeChartProps<Datum extends DefaultTreeMapDatum = TreeMapNode> = Omit<TreeMapSvgProps<Datum>, "width" | "height">;
interface ParentLabelControlOptions {
    parentSkipSize?: number;
}
type BaseTreeMapChartProps<Datum extends DefaultTreeMapDatum = TreeMapNode> = Omit<ResponsiveTreeChartProps<Datum>, "colors" | "tooltip"> & ParentLabelControlOptions;
interface TreeMapChartProps<Datum extends DefaultTreeMapDatum = TreeMapNode> extends BaseTreeMapChartProps<Datum> {
    width?: CSSProperties["width"];
    height?: CSSProperties["height"];
    rootAriaLabel?: string;
    emptyLabel?: string;
    emptyAriaLabel?: string;
    showLegend?: boolean;
    legendMinValue?: number;
    legendMaxValue?: number;
    colors: (value: number, domain?: number[]) => string;
    formatLegend?: (value: number) => string;
    legendDomain?: number[];
    tooltipRows?: TreeMapTooltipAccessor;
}
type TreeMapChartNode = DefaultTreeMapDatum;

declare const TreeMapChart: FunctionalComponent<TreeMapChartProps>;

declare const defaultTreeChartConfig: Partial<ResponsiveTreeChartProps<DefaultTreeMapDatum>>;

interface TreeMapChartWidgetProps extends Omit<TreeMapChartProps, "colors"> {
    title: string;
    colors: (value: number, domain?: number[]) => string;
    formatLegend?: (value: number) => string;
    translations: Record<string, string>;
    showLegend?: boolean;
    domain?: number[];
    legendDomain?: number[];
}

declare const TreeMapChartWidget: FunctionalComponent<TreeMapChartWidgetProps>;

type ResponsiveHeatMapProps<Datum extends HeatMapDatum = DefaultHeatMapDatum, ExtraProps extends object = Record<string, unknown>> = Omit<HeatMapSvgProps<Datum, ExtraProps>, "width" | "height">;
type BaseHeatMapProps<Datum extends HeatMapDatum = DefaultHeatMapDatum, ExtraProps extends object = Record<string, unknown>> = Omit<ResponsiveHeatMapProps<Datum, ExtraProps>, "width" | "height" | "colors">;
interface HeatMapProps<Datum extends HeatMapDatum = DefaultHeatMapDatum, ExtraProps extends object = Record<string, unknown>> extends BaseHeatMapProps<Datum, ExtraProps> {
    width?: CSSProperties["width"];
    height?: CSSProperties["height"];
    rootAriaLabel?: string;
    emptyLabel?: string;
    emptyAriaLabel?: string;
    colors: (value: number, domain?: number[]) => string;
}
type HeatMapLegendConfig = Omit<AnchoredContinuousColorsLegendProps, "scale" | "containerWidth" | "containerHeight">;

declare const HeatMap: FunctionalComponent<HeatMapProps>;

declare const defaultHeatMapMarginConfig: {
    top: number;
    right: number;
    bottom: number;
    left: number;
};
declare const DEFAULT_HEAT_MAP_EMPTY_COLOR = "#E0E0E0";
declare const DEFAULT_HEAT_MAP_HEIGHT = 400;
declare const DEFAULT_HEAT_MAP_WIDTH = "100%";
declare const DEFAULT_HEAT_MAP_EMPTY_LABEL = "No data available";
declare const DEFAULT_HEAT_MAP_EMPTY_ARIA_LABEL = "No data available";
declare const DEFAULT_HEAT_MAP_X_INNER_PADDING = 0.05;
declare const DEFAULT_HEAT_MAP_Y_INNER_PADDING = 0.05;
declare const DEFAULT_HEAT_MAP_FORCE_SQUARE = true;
declare const DEFAULT_HEAT_MAP_VALUE_FORMAT = ">-.2%";
declare const defaultHeatMapAxisLeftConfig: AxisProps;
declare const defaultHeatMapAxisTopConfig: AxisProps;
declare const defaultHeatMapLegendConfig: HeatMapLegendConfig;

interface HeatMapWidgetProps extends HeatMapProps {
    title: string;
    translations: Record<string, string>;
}

declare const HeatMapWidget: FunctionalComponent<HeatMapWidgetProps>;

type AxisConfig = {
    legend?: string;
    enabled?: boolean;
    format?: string;
    tickValues?: number | number[];
    domain?: number[];
};
interface StabilityRateDistributionWidgetProps {
    title: string;
    mode: ChartMode;
    data: BarGroup<string, string>[];
    keys: readonly string[];
    indexBy: string;
    groupMode: "grouped" | "stacked";
    height?: CSSProperties["height"];
    width?: CSSProperties["width"];
    rootAriaLabel?: string;
    colors: Record<string, string>;
    translations: Record<string, string>;
    yAxisConfig?: AxisConfig;
    xAxisConfig?: AxisConfig;
    layout?: "horizontal" | "vertical";
    threshold?: number;
}

declare const StabilityRateDistributionWidget: FunctionalComponent<StabilityRateDistributionWidgetProps>;

type Props$2 = {
    data: {
        layer: string;
        testCount: number;
        successRate: number;
        percentage: number;
    }[];
    title: string;
    translations: Record<string, string>;
    width?: JSX.CSSProperties["width"];
    height?: JSX.CSSProperties["height"];
};
declare const TestingPyramidWidget: (props: Props$2) => JSX.Element;

type I18nKeys$1 = "status.passed" | "status.failed" | "status.skipped" | "status.unknown" | "status.broken" | "percentage" | "of" | "tests.new" | "tests.flaky" | "tests.retries" | "total";
type I18nProp$1 = (key: I18nKeys$1, props?: Record<string, unknown>) => string;
type Props$1 = {
    title?: string;
    i18n?: I18nProp$1;
    data: Statistic;
    statuses?: TestStatus[];
    metric?: TestStatus;
};

declare const CurrentStatusChartWidget: FunctionalComponent<Props$1>;

type I18nKeys = "status.passed" | "status.failed" | "status.skipped" | "status.unknown" | "status.broken" | "no-history" | "no-results" | "ticks.current" | "ticks.history" | "tooltips.current" | "tooltips.history";
type I18nProp = (key: I18nKeys, props?: Record<string, unknown>) => string;
type Props = {
    title?: string;
    data: {
        statistic: Statistic;
        id: string;
        timestamp: number;
        name: string;
    }[];
    limit?: number;
    statuses?: TestStatus[];
    i18n: I18nProp;
};

declare const StatusDynamicsChartWidget: FunctionalComponent<Props>;

type TimlineTr = Pick<TestResult, "id" | "name" | "status" | "flaky" | "hidden" | "labels" | "environment" | "start" | "stop" | "duration" | "historyId">;
type TimelineSegment = {
    timeRange: [Date, Date];
    val: number;
    status: "failed" | "broken" | "passed" | "skipped" | "unknown";
    hidden?: boolean;
    label: string;
    labelGroup: string[];
    id: string;
};
type TimelineDataGroup = {
    id: string;
    name: string;
    segments: TimelineSegment[];
};
type TimelineData = TimelineDataGroup[];
type TimelineChartData = TimlineTr[];

type TimelineProps = {
    data?: TimelineData;
    width?: number;
    enableAnimations?: boolean;
    translations: {
        empty: string;
        selected: (props: {
            count: number;
            percentage: string;
            minDuration: string;
            maxDuration: string;
        }) => string;
    };
};
declare const Timeline: FunctionComponent<Omit<TimelineProps, "data"> & {
    data: TimelineChartData;
    dataId: string;
}>;

type ReportSummaryCardProps = {
    href: string;
    name: string;
    status: TestStatus;
    stats: Statistic;
    newTests: any[];
    retryTests: any[];
    flakyTests: any[];
    duration: number;
    plugin?: string;
    createdAt?: number;
    localeIso?: string;
    locales?: {
        in?: string;
        new?: string;
        flaky?: string;
        retry?: string;
        total?: string;
        failed?: string;
        broken?: string;
        passed?: string;
        skipped?: string;
        unknown?: string;
    };
};
declare const ReportSummaryCard: FunctionalComponent<ReportSummaryCardProps>;

export { ArrowButton, Attachment, AttachmentCode, AttachmentEmpty, AttachmentImage, AttachmentVideo, BarChart, BarChartWidget, Button, Code, CodeViewer, ComingSoonChartWidget, Counter, CurrentStatusChartWidget, DEFAULT_HEAT_MAP_EMPTY_ARIA_LABEL, DEFAULT_HEAT_MAP_EMPTY_COLOR, DEFAULT_HEAT_MAP_EMPTY_LABEL, DEFAULT_HEAT_MAP_FORCE_SQUARE, DEFAULT_HEAT_MAP_HEIGHT, DEFAULT_HEAT_MAP_VALUE_FORMAT, DEFAULT_HEAT_MAP_WIDTH, DEFAULT_HEAT_MAP_X_INNER_PADDING, DEFAULT_HEAT_MAP_Y_INNER_PADDING, DropdownButton, Grid, GridItem, Heading, HeatMap, HeatMapWidget, HtmlPreview, IconButton, IconLabel, Label, LanguagePicker, Link, Loadable, Menu, Modal, PageLoader, ReportLogo, ReportLogoFull, ReportSummaryCard, SearchBox, Spinner, StabilityRateDistributionWidget, StatusDynamicsChartWidget, StatusLabel, SuccessRatePieChart, SvgIcon, Tag, TestingPyramidWidget, Text, ThemeButton, Timeline, Toggle, TooltipWrapper, Tree, TreeHeader, TreeItem, TreeItemIcon, TreeMapChart, TreeMapChartWidget, TreeSection, TreeStatusBar, TrendChart, TrendChartKind, TrendChartWidget, Widget, allureIcons, defaultBarChartAxisBottomConfig, defaultBarChartAxisLeftConfig, defaultBarChartConfig, defaultBarChartLegendsConfig, defaultBarChartMarginConfig, defaultHeatMapAxisLeftConfig, defaultHeatMapAxisTopConfig, defaultHeatMapLegendConfig, defaultHeatMapMarginConfig, defaultTreeChartConfig, defaultTrendChartAxisBottomConfig, defaultTrendChartAxisLeftConfig, defaultTrendChartConfig, defaultTrendChartLegendConfig, defaultTrendChartMarginConfig, defaultTrendChartXScaleConfig, defaultTrendChartYScaleConfig, makeSymlogScale, makeSymlogScaleBySeries };
export type { BarChartProps, BarChartWidgetProps, ComingSoonChartWidgetProps, Datum, GridItemProps, GridProps, HeatMapProps, HeatMapWidgetProps, LanguagePickerProps, MeshTrendChartProps, ModalDataProps, ModalGalleryProps, ModalTranslations, ModalTranslationsProps, ParentLabelControlOptions, ReportSummaryCardProps, ResponsiveTreeChartProps, Serie, Slice, SlicesTrendChartProps, StabilityRateDistributionWidgetProps, SymlogScaleOptions, TagProps, TagSkin, Theme, ThemeButtonProps, TreeMapChartNode, TreeMapChartProps, TreeMapChartWidgetProps, TrendChartKindConfig, TrendChartProps, TrendChartSliceClickHandler, TrendChartSliceTouchHandler };
