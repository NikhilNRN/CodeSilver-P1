import type { HistoryDataPoint, SeverityLevel, Statistic, TestResult, TestStatus } from "@allurereport/core-api";
export declare enum ChartType {
    Trend = "trend",
    CurrentStatus = "currentStatus",
    StatusDynamics = "statusDynamics",
    TreeMap = "treemap",
    HeatMap = "heatmap",
    Bar = "bar",
    Funnel = "funnel",
    ComingSoon = "coming-soon"
}
export declare enum ChartDataType {
    Status = "status",
    Severity = "severity"
}
export declare enum BarChartType {
    StatusBySeverity = "statusBySeverity",
    StatusTrend = "statusTrend",
    StatusChangeTrend = "statusChangeTrend",
    DurationsByLayer = "durationsByLayer",
    FbsuAgePyramid = "fbsuAgePyramid",
    StabilityRateDistribution = "stabilityRateDistribution"
}
export declare enum FunnelChartType {
    TestingPyramid = "testingPyramid"
}
export declare enum TreeMapChartType {
    SuccessRateDistribution = "successRateDistribution",
    CoverageDiff = "coverageDiff"
}
export declare enum ChartMode {
    Raw = "raw",
    Percent = "percent",
    Diverging = "diverging"
}
export type ChartId = string;
export type TrendPointId = string;
export type TrendSliceId = string;
export type BaseMetadata = Record<string, unknown>;
export interface BaseTrendSliceMetadata extends BaseMetadata {
    executionId: string;
    executionName?: string;
}
export interface TrendPoint {
    x: string;
    y: number;
}
export type TrendSliceMetadata<Metadata extends BaseMetadata> = BaseTrendSliceMetadata & Metadata;
export interface TrendSlice<Metadata extends BaseTrendSliceMetadata = BaseTrendSliceMetadata> {
    min: number;
    max: number;
    metadata: TrendSliceMetadata<Metadata>;
}
export interface BasePieSlice {
    status: TestStatus;
    count: number;
}
export interface PieSlice extends BasePieSlice {
    d: string | null;
}
export type PieChartValues = {
    percentage: number;
    slices: PieSlice[];
};
export type BarGroupValues<T extends string = string> = Record<T, number>;
export type BarGroup<G extends string, T extends string = string> = {
    groupId: G;
} & BarGroupValues<T>;
export declare enum BarGroupMode {
    Grouped = "grouped",
    Stacked = "stacked"
}
export type NewKey<T extends string> = `new${Capitalize<T>}`;
export type RemovedKey<T extends string> = `removed${Capitalize<T>}`;
export type TreeMapNode<T extends Record<string, any> = {}> = T & {
    id: string;
    value?: number;
    colorValue?: number;
    children?: TreeMapNode<T>[];
};
export type HeatMapPoint = {
    x: string;
    y?: number;
};
export type HeatMapSerie<T extends Record<string, any> = Record<string, any>> = {
    id: string;
    data: HeatMapPoint[];
} & T;
export type ExecutionIdFn = (executionOrder: number) => string;
export type ExecutionNameFn = (executionOrder: number) => string;
export type TrendMetadataFnOverrides = {
    executionIdAccessor?: ExecutionIdFn;
    executionNameAccessor?: ExecutionNameFn;
};
export type TrendDataType = TestStatus | SeverityLevel;
export type TrendStats<T extends TrendDataType> = Record<T, number>;
export type TrendCalculationResult<T extends TrendDataType> = {
    points: Record<TrendPointId, TrendPoint>;
    series: Record<T, TrendPointId[]>;
};
export interface GenericTrendChartData<SeriesType extends string, Metadata extends BaseTrendSliceMetadata = BaseTrendSliceMetadata> {
    type: ChartType.Trend;
    dataType: ChartDataType;
    mode: ChartMode;
    title?: string;
    points: Record<TrendPointId, TrendPoint>;
    slices: Record<TrendSliceId, TrendSlice<Metadata>>;
    series: Record<SeriesType, TrendPointId[]>;
    min: number;
    max: number;
}
export type StatusTrendChartData = GenericTrendChartData<TestStatus>;
export type SeverityTrendChartData = GenericTrendChartData<SeverityLevel>;
export type TrendChartData = StatusTrendChartData | SeverityTrendChartData;
export interface BarChartData {
    type: ChartType.Bar;
    dataType: BarChartType;
    mode: ChartMode;
    title?: string;
    data: BarGroup<string, string>[];
    keys: readonly string[];
    indexBy: string;
    groupMode: BarGroupMode;
    xAxisConfig?: {
        legend?: string;
        enabled?: boolean;
        format?: string;
        domain?: number[];
        tickValues?: number | number[];
    };
    yAxisConfig?: {
        legend?: string;
        enabled?: boolean;
        format?: string;
        tickValues?: number | number[];
        domain?: number[];
    };
    layout?: "horizontal" | "vertical";
    threshold?: number;
}
export interface TreeMapChartData {
    type: ChartType.TreeMap;
    dataType: TreeMapChartType;
    title?: string;
    treeMap: TreeMapNode;
}
export interface HeatMapChartData<T extends Record<string, any> = {}> {
    type: ChartType.HeatMap;
    title?: string;
    data: HeatMapSerie<T>[];
}
export interface ComingSoonChartData {
    type: ChartType.ComingSoon;
    title?: string;
}
export interface FunnelChartData {
    type: ChartType.Funnel;
    dataType: FunnelChartType;
    title?: string;
    data: Record<string, number | string>[];
}
export interface CurrentStatusChartData {
    type: ChartType.CurrentStatus;
    title?: string;
    data: Statistic;
}
export interface StatusDynamicsChartData {
    type: ChartType.StatusDynamics;
    title?: string;
    data: {
        statistic: Statistic;
        id: string;
        timestamp: number;
        name: string;
    }[];
    limit?: number;
    statuses?: TestStatus[];
}
export type GeneratedChartData = TrendChartData | BarChartData | CurrentStatusChartData | StatusDynamicsChartData | ComingSoonChartData | TreeMapChartData | HeatMapChartData | FunnelChartData;
export type GeneratedChartsData = Record<ChartId, GeneratedChartData>;
export type TrendChartOptions = {
    type: ChartType.Trend;
    dataType: ChartDataType;
    mode?: ChartMode;
    title?: string;
    limit?: number;
    metadata?: TrendMetadataFnOverrides;
};
export type CurrentStatusChartOptions = {
    type: ChartType.CurrentStatus;
    title?: string;
    statuses?: TestStatus[];
    metric?: TestStatus;
};
export type StatusDynamicsChartOptions = {
    type: ChartType.StatusDynamics;
    title?: string;
    limit?: number;
    statuses?: TestStatus[];
};
export type BarChartOptions = {
    type: ChartType.Bar;
    dataType: BarChartType;
    mode?: ChartMode;
    title?: string;
    limit?: number;
    threshold?: number;
};
export type TreeMapChartOptions = {
    type: ChartType.TreeMap;
    dataType: TreeMapChartType;
    title?: string;
};
export type HeatMapChartOptions = {
    type: ChartType.HeatMap;
    title?: string;
};
export type ComingSoonChartOptions = {
    type: ChartType.ComingSoon;
    title?: string;
};
export type FunnelChartOptions = {
    type: ChartType.Funnel;
    dataType: FunnelChartType;
    title?: string;
    layers?: string[];
};
export type ChartOptions = TrendChartOptions | CurrentStatusChartOptions | StatusDynamicsChartOptions | BarChartOptions | ComingSoonChartOptions | TreeMapChartOptions | HeatMapChartOptions | FunnelChartOptions;
export interface AllureChartsStoreData {
    historyDataPoints: HistoryDataPoint[];
    testResults: TestResult[];
    statistic: Statistic;
}
export interface TrendDataAccessor<T extends TrendDataType> {
    getCurrentData: (storeData: AllureChartsStoreData) => TrendStats<T>;
    getHistoricalData: (historyPoint: HistoryDataPoint) => TrendStats<T>;
    getAllValues: () => readonly T[];
}
export interface BarDataAccessor<G extends string, T extends string> {
    getItems: (storeData: AllureChartsStoreData, limitedHistoryDataPoints: HistoryDataPoint[], isFullHistory: boolean) => BarGroup<G, T>[];
    getGroupKeys: () => readonly T[];
    getGroupMode: () => BarGroupMode;
}
export interface TreeMapDataAccessor<T extends TreeMapNode> {
    getTreeMap: (storeData: AllureChartsStoreData) => T;
}
export interface HeatMapDataAccessor<T extends Record<string, unknown> = {}> {
    getHeatMap: (storeData: AllureChartsStoreData) => HeatMapSerie<T>[];
}
